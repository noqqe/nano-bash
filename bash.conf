#!/bin/bash

### Configuration
# Some of my configurations stuff here...
GIT_DIRTY='*'
GIT_CLEAN=''
NANOBASH="$HOME/.nano-bash/"
PLUGINS="$NANOBASH/plugins"
OS=$(uname)
export EDITOR=$(which vim)
export PAGER=$(which less)

### Plugins
# include handmade plugins in here
if [ -d $PLUGINS ]; then
    for x in $PLUGINS/*.bash
    do
        source $x
    done
fi

### PROMPT
# Made a litte rip off from bash-it framework.
# Prompt will automatically get branch name when in
# a repository

function parse_git_dirty {
  if [[ -n $(git status -s 2> /dev/null |grep -v ^# | grep -v "working directory clean" ) ]]; then
      echo -e "$GIT_DIRTY"
  else
    echo -e "$GIT_CLEAN"
  fi
}

# Make branch and dirty status in prompt
function git_prompt_info() {
  ref=$(git symbolic-ref HEAD 2> /dev/null) || return
  echo -e " (${ref#refs/heads/}$(parse_git_dirty))"
}

# For longer commands this is useful sometimes
miniprompt() {
        PS1='$ '
}

# Finally make prompt
#PROMPT='\u@\h:\w$(git_prompt_info)$ '
PROMPT='\A \[\e[1;37m\]\u\[\e[0m\]@\[\e[1;32m\]\h\[\e[0m\]:\[\e[34m\]\w\[\e[0m\]\[\e[0m\]$(git_prompt_info) \$\[\e[0m\] '
PS1="${PROMPT}$(preexec_invoke_cmd)"

# Right terminal settings
export TERM='screen-256color'

### Bash Completion
# source compat completion directory definitions
if [ -d "$NANOBASH/completion" ]; then
    for i in $NANOBASH/completion/* ; do
        [[ -f $i && -r $i ]] && . "$i" &>/dev/null
    done
fi

# sources /etc/bash.bashrc).
if [ -f /etc/bash_completion ] && ! shopt -oq posix; then
    . /etc/bash_completion
fi

### Aliases


# some other
alias sl=ls
alias la='ls -AF'        # Compact view, show hidden
alias ll='ls -al'
alias l='ls -lah'
alias c='clear'
alias k='clear'
alias q="exit"
alias x="exit"
alias h='history'
alias re='tmux attach -d -t NOC'

# vi like aliases
alias ':q'='exit'
alias ':x'='exit'

alias editor="$EDITOR"
alias pager="$PAGER"
alias rss="newsbeuter -q"

alias ..='cd ..'        # Go up one directory
alias ...='cd ../..'    # Go up two directories
alias -- -="cd -"       # Go back


# Tree
alias tree-bash="find . -print | sed -e 's;[^/]*/;|____;g;s;____|; |;g'"

# Directory
alias md='mkdir -p'
alias rd=rmdir
alias d='dirs -v'

# lazyness ftw
alias reload='source ~/.bashrc'
alias ducks='du -cks * | sort -rn | head -11 '
alias xmod='chmod +x'
alias timestamp='date "+%Y%m%dT%H%M%S"'
alias whereami='echo "$( hostname --fqdn ) ($(hostname -i)):$( pwd )"' # Complement to whoami command.
alias uberquota='quota -gsl'

### git
# Aliases
alias gcl='git clone'
alias ga='git add'
alias gall='git add .'
alias g='git'
alias get='git'
alias gst='git status'
alias gs='git status'
alias gss='git status -s'
alias gl='git log --oneline'
alias gup='git fetch && git rebase'
alias gp='git push'
alias gpo='git push origin '
alias gb='git branch'
alias gcount='git shortlog -sn'
alias gdel='git branch -D'
alias gcm='git commit -a -m'
alias gci='git commit -a -m'
alias gll='git log --graph --pretty=oneline --abbrev-commit'
alias cdiff='git diff --cached'
alias mutt='mutt -F ~/.mutt/config'

### History - made right.
# history length
HISTSIZE=10000
HISTFILESIZE=10000

# don't put duplicate lines in the history. See bash(1) for more options
# ... or force ignoredups and ignorespace
HISTCONTROL=ignoredups:ignorespace

# setting up timestamp for history
HISTTIMEFORMAT="%F %T "

# After each command, save and reload history
export PROMPT_COMMAND="${PROMPT_COMMAND:+$PROMPT_COMMAND$'\n'}history -a; history -c; history -r"

# Reverse History
function rh {
  history | awk '{a[$4]++}END{for(i in a){print a[i] " " i}}' | sort -rn | head
}

# append to the history file, don't overwrite it
shopt -s histappend

### Includes of OS

if [ "$OS" != "Darwin" ]; then
  . $NANOBASH/os/darwin.bash
fi

if [ "$OS" == "OpenBSD" ]; then
  . $NANOBASH/os/openbsd.bash
fi

if [ "$OS" == "Linux" ]; then
  . $NANOBASH/os/linux.bash
fi

